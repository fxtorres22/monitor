<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Raspberry Pi Telemetry â€“ Bridge Dashboard</title>

<!-- Chart.js + date adapter -->
<script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.4/dist/chart.umd.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3.0.0"></script>

<style>
  :root{
    --bg:#0b1220; --panel:#10192e; --ink:#e5e7eb; --muted:#94a3b8; --ring:#233052;
    --accent:#60a5fa; --ok:#22c55e; --warn:#f59e0b; --hot:#ef4444; --grid:#1b2947;
    --chip:#0f172a;
  }
  *{box-sizing:border-box}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,"Segoe UI",Roboto,Arial,sans-serif}
  .wrap{max-width:1200px;margin:28px auto;padding:0 16px}
  .header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:16px}
  h1{font-size:1.25rem;margin:0}
  .card{background:var(--panel);border:1px solid var(--ring);border-radius:14px;padding:16px;box-shadow:0 10px 30px rgba(0,0,0,.25);margin-bottom:16px}
  .summary-row{display:grid;grid-template-columns:repeat(3,minmax(0,1fr));gap:12px}
  .kv{background:var(--chip);border:1px solid var(--ring);border-radius:12px;padding:12px}
  .k{font-size:.8rem;color:var(--muted);margin-bottom:6px}
  .v{font-size:1.05rem}
  .chip{display:inline-flex;align-items:center;gap:.5ch;padding:.25rem .6rem;border-radius:999px;border:1px solid var(--ring);background:var(--chip);font-size:.85rem}
  .chip.ok{border-color:rgba(34,197,94,.3);box-shadow:0 0 0 2px rgba(34,197,94,.08) inset}
  .chip.idle{border-color:rgba(99,102,241,.25);box-shadow:0 0 0 2px rgba(99,102,241,.06) inset}
  .chip.warn{border-color:rgba(245,158,11,.3);box-shadow:0 0 0 2px rgba(245,158,11,.08) inset}
  .controls{display:flex;flex-wrap:wrap;gap:10px;align-items:end}
  label{display:flex;flex-direction:column;font-size:.85rem;color:var(--muted);gap:6px}
  input,select,button{
    background:var(--chip);color:var(--ink);border:1px solid var(--ring);
    border-radius:10px;padding:8px 10px;font-size:.95rem;outline:none
  }
  button{cursor:pointer}
  .hint{font-size:.85rem;color:var(--muted)}
  .row-2{display:grid;grid-template-columns:repeat(2,minmax(0,1fr));gap:16px}
  @media (max-width:900px){ .summary-row{grid-template-columns:1fr} .row-2{grid-template-columns:1fr} }
  .title{display:flex;align-items:center;justify-content:space-between;margin-bottom:10px}
  .title h2{font-size:1.05rem;margin:0}
  .legend-note{font-size:.8rem;color:var(--muted)}

  /* âœ… Stable chart sizing: fixed-height parent, canvas fills it */
  .chart{height:340px; position:relative}
  canvas{width:100% !important; height:100% !important; display:block}
</style>
</head>
<body>
<div class="wrap">

  <div class="header">
    <h1>Bridge Telemetry</h1>
    <span class="chip" id="refreshStatus">Next auto-refresh in 10:00</span>
  </div>

  <!-- Summary -->
  <div class="card">
    <div class="title">
      <h2>1) Summary</h2>
      <span class="legend-note">Data refreshes every 10 minutes</span>
    </div>
    <div class="summary-row">
      <div class="kv">
        <div class="k">Host</div>
        <div class="v" id="hostName">â€”</div>
      </div>
      <div class="kv">
        <div class="k">Last point (local)</div>
        <div class="v" id="lastTs">â€”</div>
      </div>
      <div class="kv">
        <div class="k">Bridge status</div>
        <div class="v"><span class="chip idle" id="bridgeStatus">â€”</span></div>
      </div>
    </div>
  </div>

  <!-- Range controls -->
  <div class="card">
    <div class="title">
      <h2>Range</h2>
      <span class="legend-note">Default: last 48 hours</span>
    </div>
    <div class="controls">
      <label>Preset
        <select id="presetSelect">
          <option value="12h">Last 12 hours</option>
          <option value="24h">Last 24 hours</option>
          <option value="48h" selected>Last 48 hours</option>
          <option value="7d">Last 7 days</option>
          <option value="all">All data</option>
        </select>
      </label>
      <label>Start
        <input type="datetime-local" id="startInput">
      </label>
      <label>End
        <input type="datetime-local" id="endInput">
      </label>
      <button id="applyBtn">Apply</button>
      <button id="resetBtn" title="Reset to default 48h">Reset</button>
    </div>
  </div>

  <!-- 2) Temperature -->
  <div class="card">
    <div class="title"><h2>2) Temperature (Â°C)</h2></div>
    <div class="chart"><canvas id="tempChart"></canvas></div>
    <div class="hint">Grid every 10 minutes; labels show each full hour.</div>
  </div>

  <!-- 3) CPU & RAM -->
  <div class="card">
    <div class="title"><h2>3) CPU & RAM (%)</h2></div>
    <div class="chart"><canvas id="cpuRamChart"></canvas></div>
  </div>

  <!-- 4 & 5) WAN / LAN throughput -->
  <div class="row-2">
    <div class="card">
      <div class="title"><h2>4) WAN Throughput (Rx/Tx, Mb/s)</h2></div>
      <div class="chart"><canvas id="wanChart"></canvas></div>
    </div>
    <div class="card">
      <div class="title"><h2>5) LAN Throughput (Rx/Tx, Mb/s)</h2></div>
      <div class="chart"><canvas id="lanChart"></canvas></div>
    </div>
  </div>

</div>

<script>
/* ðŸ”— SET YOUR NDJSON URL HERE */
const NDJSON_URL = "https://example.com/telemetry.ndjson";

/* Auto-refresh period (ms) */
const REFRESH_MS = 10 * 60 * 1000;

/* Chart.js global defaults */
Chart.defaults.responsive = true;
Chart.defaults.maintainAspectRatio = false;

/* State */
let rawData = [];          // all rows from NDJSON (parsed objects)
let filtered = [];         // rows after range filtering
let charts = {};           // Chart.js instances
let nextRefreshAt = Date.now() + REFRESH_MS;

/* ---------- Utils ---------- */
const fmtLocal = (d)=> new Date(d).toLocaleString();
const byTsAsc = (a,b)=> new Date(a.ts) - new Date(b.ts);

/* Convert cumulative bytes to Mb/s using deltas between consecutive points */
function toRatesMbPerSec(rows, rxKey, txKey){
  const out = rows.map((r,i)=>{
    if(i===0){ return { t:new Date(r.ts), rx:null, tx:null }; }
    const dt = (new Date(rows[i].ts) - new Date(rows[i-1].ts)) / 1000; // seconds
    const drx = Math.max(0, (r[rxKey] ?? 0) - (rows[i-1][rxKey] ?? 0));
    const dtx = Math.max(0, (r[txKey] ?? 0) - (rows[i-1][txKey] ?? 0));
    const rxbps = dt>0 ? (drx*8)/dt : 0;
    const txbps = dt>0 ? (dtx*8)/dt : 0;
    return { t:new Date(r.ts), rx: rxbps/1e6, tx: txbps/1e6 };
  });
  return out;
}

/* Compute Bridge Status (last hour). */
function computeBridgeStatus(rows){
  if(rows.length < 2) return {label:"No data", cls:"warn"};
  const windowMs = 60*60*1000; // 1h
  const end = new Date(rows[rows.length-1].ts).getTime();
  const start = end - windowMs;
  const slice = rows.filter(r => new Date(r.ts).getTime() >= start);
  if(slice.length < 2) return {label:"Insufficient data", cls:"warn"};

  let wan=0, lan=0;
  for(let i=1;i<slice.length;i++){
    const a = slice[i-1], b = slice[i];
    wan += Math.max(0, (b.wan_rx_bytes - a.wan_rx_bytes)) + Math.max(0, (b.wan_tx_bytes - a.wan_tx_bytes));
    lan += Math.max(0, (b.lan_rx_bytes - a.lan_rx_bytes)) + Math.max(0, (b.lan_tx_bytes - a.lan_tx_bytes));
  }
  const MB = 1024*1024;
  const tiny = (wan+lan) < (5*MB); // < ~5 MB over the hour â†’ idle traffic
  if(tiny) return {label:"Idle", cls:"idle"};

  const diff = Math.abs(wan - lan);
  const rel = diff / Math.max(wan, lan, 1);
  if(rel <= 0.2) return {label:"Active", cls:"ok"};
  return {label:"Idle", cls:"idle"};
}

/* X time scale: grid every 10 minutes; labels only on the hour */
function timeScaleOptions(){
  const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--grid').trim() || '#1b2947';
  return {
    type: 'time',
    time: { unit: 'minute', stepSize: 10 },
    ticks: {
      autoSkip: false,
      callback: (value) => {
        const d = new Date(value);
        return d.getMinutes() === 0
          ? d.toLocaleTimeString([], {hour:'2-digit', minute:'2-digit'})
          : '';
      },
      color:'#cbd5e1'
    },
    grid: { color: gridColor }
  };
}

function ds(label, data, yAxisID, tension=0.25){
  return { label, data, parsing:false, spanGaps:true, borderWidth:2, pointRadius:0, yAxisID, cubicInterpolationMode:'monotone', tension };
}

/* Create/update charts */
function renderCharts(){
  const T = filtered.map(r => ({x:new Date(r.ts), y:r.temp_c}));
  const CPU = filtered.map(r => ({x:new Date(r.ts), y:r.cpu_percent}));
  const RAM = filtered.map(r => ({x:new Date(r.ts), y:r.ram_percent}));

  const WAN = toRatesMbPerSec(filtered, 'wan_rx_bytes', 'wan_tx_bytes');
  const WAN_RX = WAN.map(p => ({x:p.t, y:p.rx}));
  const WAN_TX = WAN.map(p => ({x:p.t, y:p.tx}));

  const LAN = toRatesMbPerSec(filtered, 'lan_rx_bytes', 'lan_tx_bytes');
  const LAN_RX = LAN.map(p => ({x:p.t, y:p.rx}));
  const LAN_TX = LAN.map(p => ({x:p.t, y:p.tx}));

  charts.temp?.destroy();
  charts.temp = new Chart(document.getElementById('tempChart'), {
    type: 'line',
    data: { datasets: [ ds('Temp Â°C', T, 'y') ] },
    options: {
      animation:false,
      scales:{
        x: timeScaleOptions(),
        y: { ticks:{ color:'#cbd5e1' }, grid:{ color:'#1f2a44' } }
      },
      plugins:{ legend:{ labels:{ color:'#cbd5e1' } }, tooltip:{ mode:'index', intersect:false } }
    }
  });

  charts.cpu?.destroy();
  charts.cpu = new Chart(document.getElementById('cpuRamChart'), {
    type: 'line',
    data: { datasets: [ ds('CPU %', CPU, 'y'), ds('RAM %', RAM, 'y') ] },
    options: {
      animation:false,
      scales:{
        x: timeScaleOptions(),
        y: { min:0, max:100, ticks:{ color:'#cbd5e1' }, grid:{ color:'#1f2a44' } }
      },
      plugins:{ legend:{ labels:{ color:'#cbd5e1' } }, tooltip:{ mode:'index', intersect:false } }
    }
  });

  charts.wan?.destroy();
  charts.wan = new Chart(document.getElementById('wanChart'), {
    type: 'line',
    data: { datasets: [ ds('WAN Rx (Mb/s)', WAN_RX, 'y'), ds('WAN Tx (Mb/s)', WAN_TX, 'y') ] },
    options: {
      animation:false,
      scales:{
        x: timeScaleOptions(),
        y: { beginAtZero:true, ticks:{ color:'#cbd5e1' }, grid:{ color:'#1f2a44' } }
      },
      plugins:{ legend:{ labels:{ color:'#cbd5e1' } }, tooltip:{ mode:'index', intersect:false } }
    }
  });

  charts.lan?.destroy();
  charts.lan = new Chart(document.getElementById('lanChart'), {
    type: 'line',
    data: { datasets: [ ds('LAN Rx (Mb/s)', LAN_RX, 'y'), ds('LAN Tx (Mb/s)', LAN_TX, 'y') ] },
    options: {
      animation:false,
      scales:{
        x: timeScaleOptions(),
        y: { beginAtZero:true, ticks:{ color:'#cbd5e1' }, grid:{ color:'#1f2a44' } }
      },
      plugins:{ legend:{ labels:{ color:'#cbd5e1' } }, tooltip:{ mode:'index', intersect:false } }
    }
  });
}

/* Apply range filter */
function applyRange(){
  if(rawData.length===0){ filtered = []; return; }

  const preset = document.getElementById('presetSelect').value;
  const startVal = document.getElementById('startInput').value;
  const endVal = document.getElementById('endInput').value;

  let startMs, endMs;
  if(endVal) endMs = new Date(endVal).getTime();
  if(startVal) startMs = new Date(startVal).getTime();

  const lastTs = new Date(rawData[rawData.length-1].ts).getTime();
  const spans = { '12h':12*3600e3, '24h':24*3600e3, '48h':48*3600e3, '7d':7*24*3600e3 };

  if(!startMs || !endMs){
    if(preset === 'all'){
      startMs = new Date(rawData[0].ts).getTime();
      endMs = lastTs;
    }else{
      const span = spans[preset] ?? spans['48h'];
      startMs = lastTs - span;
      endMs = lastTs;
    }
  }

  filtered = rawData.filter(r => {
    const t = new Date(r.ts).getTime();
    return t >= startMs && t <= endMs;
  });

  if(filtered.length < 2){
    filtered = [...rawData];
  }
}

/* Fetch and parse NDJSON */
async function fetchNdjson(){
  const res = await fetch(NDJSON_URL, { cache:'no-store' });
  if(!res.ok) throw new Error(`Fetch failed: ${res.status}`);
  const text = await res.text();
  const lines = text.split(/\r?\n/).filter(l => l.trim().length>0);
  const rows = [];
  for(const line of lines){
    try{
      const obj = JSON.parse(line);
      if(obj && obj.ts) rows.push(obj);
    }catch(e){ /* ignore bad lines */ }
  }
  rows.sort(byTsAsc);
  return rows;
}

/* Update summary */
function updateSummary(){
  const hostEl = document.getElementById('hostName');
  const lastEl = document.getElementById('lastTs');
  const badge  = document.getElementById('bridgeStatus');

  if(rawData.length===0){
    hostEl.textContent = 'â€”';
    lastEl.textContent = 'â€”';
    badge.textContent  = 'No data';
    badge.className = 'chip warn';
    return;
  }
  const last = rawData[rawData.length-1];
  hostEl.textContent = last.host ?? 'â€”';
  lastEl.textContent = fmtLocal(last.ts);

  const st = computeBridgeStatus(rawData);
  badge.textContent = st.label;
  badge.className = `chip ${st.cls}`;
}

/* Countdown label */
function startRefreshCountdown(){
  const el = document.getElementById('refreshStatus');
  function tick(){
    const sec = Math.max(0, Math.ceil((nextRefreshAt - Date.now())/1000));
    const m = String(Math.floor(sec/60)).padStart(1,'0');
    const s = String(sec%60).padStart(2,'0');
    el.textContent = `Next auto-refresh in ${m}:${s}`;
    if(sec<=0){ nextRefreshAt = Date.now()+REFRESH_MS; }
    requestAnimationFrame(tick);
  }
  tick();
}

/* Load + draw flow */
async function loadAndRender(){
  rawData = await fetchNdjson();
  updateSummary();
  applyRange();
  renderCharts();
}

/* Wire UI */
document.getElementById('applyBtn').addEventListener('click', ()=>{
  applyRange();
  renderCharts();
});
document.getElementById('resetBtn').addEventListener('click', ()=>{
  document.getElementById('presetSelect').value = '48h';
  document.getElementById('startInput').value = '';
  document.getElementById('endInput').value = '';
  applyRange();
  renderCharts();
});
document.getElementById('presetSelect').addEventListener('change', ()=>{
  document.getElementById('startInput').value = '';
  document.getElementById('endInput').value = '';
});

/* Boot */
(async ()=>{
  try{
    await loadAndRender();
  }catch(err){
    console.error(err);
    alert("Failed to load telemetry. Check NDJSON_URL or network console.");
  }
  startRefreshCountdown();
  setInterval(async ()=>{
    try{ await loadAndRender(); }catch(e){ console.error(e); }
  }, REFRESH_MS);
})();
</script>
</body>
</html>
