<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Raspberry Pi Telemetry</title>
<style>
  :root{--bg:#0f172a;--card:#1e293b;--ink:#f9fafb;--muted:#94a3b8;--ring:#334155;
        --ok:#22c55e;--hot:#f87171;--accent:#60a5fa;}
  html,body{margin:0;padding:0;background:var(--bg);color:var(--ink);
    font-family:system-ui,-apple-system,Segoe UI,Roboto,Arial,sans-serif;}
  .wrap{max-width:1080px;margin:24px auto;padding:0 12px;}
  .card{background:var(--card);border:1px solid var(--ring);border-radius:14px;
    box-shadow:0 4px 14px rgba(0,0,0,.3);padding:16px 20px;margin-bottom:16px;}
  .row{display:flex;gap:24px;flex-wrap:wrap;align-items:baseline;}
  .stat{font-size:2.2rem;font-weight:700;}
  .muted{color:var(--muted);font-size:.95rem;}
  #cur.stat.hot{color:var(--hot);}#cur.stat.ok{color:var(--ok);}
  canvas{width:100%;height:360px;}
  .controls{display:flex;gap:16px;align-items:center;margin:8px 0;}
  .badge{border:1px solid var(--ring);border-radius:999px;padding:4px 10px;font-size:.9rem;color:var(--muted);margin-left:8px}
  .bridgeStatus{display:flex;gap:12px;align-items:center;flex-wrap:wrap;justify-content:space-between}
  .bridgeText{font-weight:900;font-size:1.6rem;letter-spacing:.02em}
  .bridgeText.active{color:#ff6b6b;}
  .bridgeText.idle{color:#22c55e;}
  hr{border:none;border-top:1px solid var(--ring);margin:12px 0;}
</style>
</head>
<body>
<div class="wrap">
  <div class="card">
    <div class="row">
      <div><div class="muted">Host</div><div id="host" class="stat">—</div></div>
      <div><div class="muted">Temp (°C)</div><div id="cur" class="stat">—</div></div>
      <div><div class="muted">Updated (<span id="tz-label">Local</span>)</div>
           <div id="upd" class="stat" style="font-size:1.1rem;">—</div></div>
    </div>

    <div class="controls">
      <label><input type="checkbox" id="tzToggle"> Show times in UTC</label>
      <span class="muted">Auto-refresh 60 s</span>
      <span id="wanBadge" class="badge">wan: —</span>
      <span id="lanBadge" class="badge">lan: —</span>
    </div>

    <div class="bridgeStatus">
      <div id="bridgeText" class="bridgeText idle">BRIDGE: idle</div>
      <div class="muted" id="bridgeHint">Based on WAN/LAN traffic in last interval</div>
    </div>
  </div>

  <div class="card"><canvas id="chartTemp"></canvas></div>
  <div class="card"><canvas id="chartCpuRam"></canvas></div>
  <div class="card"><canvas id="chartNet"></canvas></div>
</div>

<script src="https://cdn.jsdelivr.net/npm/chart.js@4"></script>
<script src="https://cdn.jsdelivr.net/npm/chartjs-adapter-date-fns@3"></script>
<script>
/* ---------- CONFIG ---------- */
// Public charts blob (host-scoped). Change host segment if needed.
const BLOB_URL = "https://storagetemperaturedata.blob.core.windows.net/charts/temps.json";
const HOT_THRESHOLD = 70;

/* ---------- STATE ---------- */
let useLocalTZ = true;
let charts = {};

/* ---------- HELPERS ---------- */
function fmtUTC(d){return d.toISOString().replace('T',' ').slice(0,19)+'Z';}
function fmtLocal(d){return d.toLocaleString([], {year:'numeric',month:'2-digit',day:'2-digit',
                                                  hour:'2-digit',minute:'2-digit',second:'2-digit'});}
async function fetchJsonNoCache(url){
  const r=await fetch(url+(url.includes('?')?'&':'?')+'_ts='+Date.now(),{cache:'no-store'});
  if(!r.ok)throw new Error('fetch '+r.status); return await r.json();
}
function toPoints(arr, key){return arr.map(d=>({x:new Date(d.ts), y:Number(d[key])})).filter(p=>Number.isFinite(p.y));}
function mbpsFromBps(bps){return (bps==null)?null:(bps/1_000_000);}

/* Normalize Logic App payload: count->number, data->array (even if stringified) */
function normalizePayload(j){
  let data;
  if (Array.isArray(j?.data)) {
    data = j.data;
  } else if (typeof j?.data === 'string') {
    try { data = JSON.parse(j.data); } catch { data = []; }
  } else {
    data = [];
  }
  const cnt = Number.isFinite(Number(j?.count)) ? Number(j.count) : data.length;
  return { updated_utc: j?.updated_utc ?? null, count: cnt, data };
}

/* Derive bps from byte counters + timestamps */
function addDerivedNetRates(arr){
  for (let i = 1; i < arr.length; i++){
    const a = arr[i-1], b = arr[i];
    const ta = new Date(a.ts).getTime(), tb = new Date(b.ts).getTime();
    const dt = (tb - ta)/1000;
    if (dt > 0){
      const d = (key) => (Number(b[key] ?? 0) - Number(a[key] ?? 0)) / dt;
      b.wan_rx_bps = Math.max(0, d('wan_rx_bytes'));
      b.wan_tx_bps = Math.max(0, d('wan_tx_bytes'));
      b.lan_rx_bps = Math.max(0, d('lan_rx_bytes'));
      b.lan_tx_bps = Math.max(0, d('lan_tx_bytes'));
    } else {
      b.wan_rx_bps = b.wan_tx_bps = b.lan_rx_bps = b.lan_tx_bps = null;
    }
  }
}

/* --- snap domains so grid lands on exact :00/:10/:20... boundaries --- */
function floorTo10m(ms, useLocal) {
  const d = new Date(ms);
  let Y=d.getFullYear(), M=d.getMonth(), D=d.getDate(), h=useLocal?d.getHours():d.getUTCHours();
  let m = useLocal?d.getMinutes():d.getUTCMinutes();
  const snap = Math.floor(m/10)*10;
  return (useLocal ? new Date(Y,M,D,h,snap,0,0) : new Date(Date.UTC(Y,M,D,h,snap,0,0))).getTime();
}
function ceilTo10m(ms, useLocal) { const f=floorTo10m(ms,useLocal); return (f===ms)?ms:f+10*60*1000; }
function computeDomain10m(points, useLocal) {
  if (!points.length) return {};
  const t0=points[0].x.getTime(), t1=points[points.length-1].x.getTime();
  return {min: floorTo10m(t0,useLocal), max: ceilTo10m(t1,useLocal)};
}

/* --------- time axis: grid every 10 min, labels only at the hour --------- */
function xTimeScale(min=null, max=null) {
  return {
    type:'time',
    distribution:'linear',
    bounds:'ticks',
    min, max,
    time:{ unit:'minute', stepSize:10, round:'minute' },
    ticks:{
      autoSkip:false, maxRotation:0, minRotation:0, color:'#e2e8f0',
      callback:(v)=>{
        const d=new Date(v);
        const mins = useLocalTZ ? d.getMinutes() : d.getUTCMinutes();
        if (mins !== 0) return '';
        return useLocalTZ
          ? d.toLocaleTimeString([], {hour:'numeric'})
          : d.toISOString().substring(11,13)+":00 UTC";
      }
    },
    grid:{ color:'rgba(148,163,184,.2)' }
  };
}

/* --------- tooltip titles honor timezone --------- */
function tooltipTitle(ctx){
  const d = new Date(ctx[0].parsed.x);
  return useLocalTZ ? fmtLocal(d) : fmtUTC(d);
}

/* --------- temp threshold shading + tiny label --------- */
const thresholdFillPlugin = {
  id: 'thresholdFill',
  beforeDraw(chart) {
    const yS = chart.scales.y, area = chart.chartArea;
    if (!yS || !area) return;
    const y = yS.getPixelForValue(HOT_THRESHOLD);
    const ctx = chart.ctx;
    ctx.save(); ctx.globalAlpha=0.22; ctx.fillStyle='#ef4444';
    ctx.fillRect(area.left,area.top,area.right-area.left,Math.max(0,y-area.top)); ctx.restore();
    ctx.save(); ctx.strokeStyle='#ff6b6b'; ctx.lineWidth=1.25; ctx.setLineDash([6,4]);
    ctx.beginPath(); ctx.moveTo(area.left,y); ctx.lineTo(area.right,y); ctx.stroke(); ctx.restore();
    ctx.save(); ctx.font='12px system-ui,-apple-system,Segoe UI,Roboto,Arial'; ctx.fillStyle='#ffd7d7';
    ctx.textAlign='right'; ctx.textBaseline='bottom'; ctx.fillText(`${HOT_THRESHOLD} °C`, area.right-6, y-4); ctx.restore();
  }
};

/* --------- chart factory --------- */
function makeChart(ctx, datasets, plugins=[]) {
  return new Chart(ctx, {
    type:'line',
    data:{ datasets },
    options:{
      parsing:true, animation:false, normalized:true,
      plugins:{
        legend:{display:true, labels:{color:'#e2e8f0'}},
        tooltip:{mode:'index', intersect:false, callbacks:{ title: tooltipTitle }}
      },
      scales:{ x: xTimeScale(), y:{ ticks:{color:'#e2e8f0'}, grid:{color:'rgba(148,163,184,.2)'} } }
    },
    plugins
  });
}

/* ---------------- render ---------------- */
function render(j){
  const data = Array.isArray(j.data) ? j.data : [];
  const last = data.length ? data[data.length-1] : null;
  const host = last?.host ?? 'raspberrypi';
  document.getElementById('host').textContent = host;

  // Summary
  const curTemp = last ? Number(last.temp_c) : NaN;
  const curEl = document.getElementById('cur');
  curEl.textContent = isFinite(curTemp) ? curTemp.toFixed(1) : '—';
  curEl.className = 'stat ' + (isFinite(curTemp) ? (curTemp>=HOT_THRESHOLD?'hot stat':'ok stat') : 'stat');

  const upd = last ? new Date(last.ts) : null;
  document.getElementById('tz-label').textContent = useLocalTZ ? 'Local' : 'UTC';
  document.getElementById('upd').textContent = upd ? (useLocalTZ ? fmtLocal(upd) : fmtUTC(upd)) : '—';

  // Bridge info
  const wanIf = last?.wan_if ?? '—';
  const lanIf = last?.lan_if ?? '—';
  document.getElementById('wanBadge').textContent = 'wan: ' + wanIf;
  document.getElementById('lanBadge').textContent = 'lan: ' + lanIf;
  const bridge = !!last?.bridge_active;
  const bt = document.getElementById('bridgeText');
  bt.textContent = 'BRIDGE: ' + (bridge ? 'ACTIVE' : 'idle');
  bt.className = 'bridgeText ' + (bridge ? 'active' : 'idle');

  // Datasets
  const ptsTemp   = toPoints(data, 'temp_c');
  const ptsCPU    = toPoints(data, 'cpu_percent');
  const ptsRAM    = toPoints(data, 'ram_percent');
  const ptsUpMbps = toPoints(data, 'wan_tx_bps').map(p=>({x:p.x, y: mbpsFromBps(p.y)})).filter(p=>p.y!=null);
  const ptsDnMbps = toPoints(data, 'wan_rx_bps').map(p=>({x:p.x, y: mbpsFromBps(p.y)})).filter(p=>p.y!=null);

  // Domains snapped to 10-min boundaries
  const domTemp = computeDomain10m(ptsTemp, useLocalTZ);
  const domCpu  = computeDomain10m(ptsCPU.length?ptsCPU:ptsRAM, useLocalTZ);
  const baseNet = ptsUpMbps.length?ptsUpMbps:ptsDnMbps;
  const domNet  = computeDomain10m(baseNet, useLocalTZ);

  // Temperature
  if(!charts.temp){
    charts.temp = makeChart(document.getElementById('chartTemp').getContext('2d'), [
      {label:'Temperature (°C)', data: ptsTemp, borderColor:'#60a5fa', pointRadius:0, tension:.2}
    ], [thresholdFillPlugin]);
    charts.temp.options.scales.y.suggestedMin = 20;
    charts.temp.options.scales.y.suggestedMax = 80;
  }
  charts.temp.data.datasets[0].data = ptsTemp;
  charts.temp.options.scales.x = xTimeScale(domTemp.min, domTemp.max);
  charts.temp.update();

  // CPU & RAM
  if(!charts.cpu){
    charts.cpu = makeChart(document.getElementById('chartCpuRam').getContext('2d'), [
      {label:'CPU %', data: ptsCPU, borderColor:'#93c5fd', pointRadius:0, tension:.2},
      {label:'RAM %', data: ptsRAM, borderColor:'#a78bfa', pointRadius:0, tension:.2}
    ]);
    charts.cpu.options.scales.y.suggestedMin = 0;
    charts.cpu.options.scales.y.suggestedMax = 100;
  }
  charts.cpu.data.datasets[0].data = ptsCPU;
  charts.cpu.data.datasets[1].data = ptsRAM;
  charts.cpu.options.scales.x = xTimeScale(domCpu.min, domCpu.max);
  charts.cpu.update();

  // Network (WAN Mb/s)
  if(!charts.net){
    charts.net = makeChart(document.getElementById('chartNet').getContext('2d'), [
      {label:'Upload (Mb/s)',   data: ptsUpMbps, borderColor:'#34d399', pointRadius:0, tension:.2},
      {label:'Download (Mb/s)', data: ptsDnMbps, borderColor:'#f472b6', pointRadius:0, tension:.2}
    ]);
  }
  charts.net.data.datasets[0].data = ptsUpMbps;
  charts.net.data.datasets[1].data = ptsDnMbps;
  charts.net.options.scales.x = xTimeScale(domNet.min, domNet.max);
  charts.net.update();
}

/* ---------------- boot ---------------- */
async function loadAndRender(){
  try{
    const raw = await fetchJsonNoCache(BLOB_URL);
    const norm = normalizePayload(raw);
    addDerivedNetRates(norm.data);
    render(norm);
  }catch(e){ console.error(e); }
}
document.getElementById('tzToggle').addEventListener('change', e=>{ useLocalTZ = !useLocalTZ; loadAndRender(); });
loadAndRender(); setInterval(loadAndRender, 60_000);
</script>
</body>
</html>
